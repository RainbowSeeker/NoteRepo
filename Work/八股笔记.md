# Note For Embedding

## 1. Basic C/C++

### fopen

```c
FILE *fopen(const char *filename, const char *mode);
```

`mode`参数:

| mode |                    desc                    |
| :--: | :----------------------------------------: |
|  r   |           只读文本，不存在则失败           |
|  w   |      只写文本，截断文件，不存在则创建      |
|  a   | 追加文本，写入位置在文件末尾，不存在则创建 |
|  b   |            替换为**二进制**操作            |
|  +   |                    读写                    |

> `rb+`：读写（二进制），文件必须存在

### :question:struct

```c
struct Question1 {
    char a;			// 占用 1 字节
    double b;		// 占用 8 字节，但为对齐前面补上 7 字节
    int c;			// 占用 4 字节
    char d[];		// 占用 0 字节
    // 需整体对齐到8（最大成员`double`），故填充4字节
};	
```

- 实际占 `24` 个字节

```c
#pragma pack(2)
struct Question2 {
    char a;
    int b;
    short c;
}; //__attribute__((packed))
#pragma pack()
```

- 实际占 `8` 个字节

### setvbuf

- 缓冲类型：

  - **全缓冲**（`_IOFBF`）：缓冲区满时刷新（默认用于文件）。
  - **行缓冲**（`_IOLBF`）：遇到换行符或缓冲区满时刷新（默认用于终端）。
  - **无缓冲**（`_IONBF`）：直接读写。

- 手动设置缓冲

  ```c
  char buffer[1024];
  setvbuf(fp, buffer, _IOFBF, sizeof(buffer)); // 设置全缓冲
  ```

## 2. Hardware

### :star2:CAN

特点：

- **多主架构**：任何节点均可主动发起通信。
- **非破坏性仲裁**：基于标识符优先级解决冲突，高优先级帧继续发送。
- **差分信号**：使用CAN_H和CAN_L双绞线传输，抗干扰能力强。（压差2V：逻辑 0 **显性**电平，压差0V：逻辑 1 **隐性**电平）。
- **高可靠性**：内置CRC校验、错误检测与恢复机制。

#### :sparkles:**数据链路层**：

|   帧类型   |                        用途                        |
| :--------: | :------------------------------------------------: |
| **数据帧** |        用于发送单元向接收单元传送数据的帧。        |
| **遥控帧** | 用于接收单元向具有相同 ID 的发送单元请求数据的帧。 |
| **错误帧** |     用于当检测出错误时向其它单元通知错误的帧。     |
| **过载帧** |      用于接收单元通知其尚未做好接收准备的帧。      |

##### 数据帧：

用于发送单元向接收单元传送数据的帧。

- **标准帧（11位ID）**：

  ```
  SOF | ID (11位) | RTR | IDE | r0 | DLC (4位) | Data (0-8字节) | CRC (15位) | CRC Delimiter | ACK Slot | ACK Delimiter | EOF
  帧起始 --> 仲裁段       --> 控制段              --> 数据段        --> CRC                     --> 帧结束
  ```

- **扩展帧（29位ID）**：

  ```
  SOF | ID (11位) | SRR | IDE | ID扩展 (18位) | RTR | r1 | DLC (4位) | Data (0-8字节) | CRC | CRC Delimiter | ACK Slot | ACK Delimiter | EOF
  ```

**关键字段说明**：

- **SOF（Start Of Frame）**：显性电平，标志帧开始。
- **ID（Identifier）**：决定帧优先级，数值越小优先级越高。
- **RTR（Remote Transmission Request）**：0表示数据帧，1表示远程帧。
- **DLC（Data Length Code）**：数据段长度（0-8字节）。
- **CRC（Cyclic Redundancy Check）**：校验数据段和控制场。
- **ACK Slot**：发送节点发送隐性位，接收节点以显性位确认。

> Q1：CAN的CRC校验是否覆盖ACK场？
>
> A1：不覆盖。ACK场由接收方在确认阶段填充，不属于发送方数据的一部分。CRC校验范围包括SOF、仲裁场、控制场、数据场。
>
> Q2：CAN的CRC校验是否包含填充位？
> A2：不包含。CRC计算基于原始未填充的数据，填充位由数据链路层在CRC计算后插入。

##### **遥控帧**

用于接收单元向具有相同 ID 的发送单元请求数据的帧。

### PCIe

一种**高速串行点对点**总线标准，用于连接处理器与外围设备（如显卡、SSD、网卡等）。

特点：

- **差分信号传输**：使用TX+/TX-和RX+/RX-双绞线，抗干扰能力强。
- **点对点拓扑**：每个设备独占链路（Lane），避免总线争用。
- **分层协议栈**：物理层、数据链路层、事务层与应用层分离，支持模块化设计。
- **可扩展带宽**：通过增加通道数（x1、x4、x8、x16）和提升速率（Gen1~Gen6）扩展带宽。

#### 物理层

1. **通道（Lane）与链路（Link）**

   - **单通道（x1）**：包含1对TX和1对RX差分线，独立传输数据。
   - **多通道链路**：x4、x8、x16链路通过聚合多个通道提升带宽（如x16=16条双向通道）。

2. **编码与速率**

   | PCIe版本 |  编码方式   | 单通道速率（GT/s） | 单通道带宽 |
   | :------: | :---------: | :----------------: | :--------: |
   |   Gen1   |   8b/10b    |        2.5         |  250 MB/s  |
   |   Gen2   |   8b/10b    |        5.0         |  512 MB/s  |
   |   Gen3   |  128b/130b  |        8.0         |  ~1 GB/s   |
   |   Gen4   |  128b/130b  |        16.0        |  ~2 GB/s   |
   |   Gen5   |  128b/130b  |        32.0        |  ~4 GB/s   |
   |   Gen6   | PAM4 + FLIT |        64.0        |  ~8 GB/s   |

3. **物理层功能**

   - **信号调制**：NRZ（Non-Return-to-Zero）或PAM4（Gen6）。
   - **时钟恢复**：接收端通过CDR（Clock Data Recovery）从数据流中提取时钟。
   - **链路训练**：自动协商速率、通道极性、均衡参数（如预加重/去加重）。

#### 协议层

##### 1. **事务层（Transaction Layer）**

- **TLP（Transaction Layer Packet）**：

  - **头部（Header）**：包含事务类型（读/写/配置）、地址、长度等信息。
  - **数据载荷（Data Payload）**：最大4096字节（Gen3及以上）。
  - **ECRC（End-to-End CRC）**：可选校验字段，保护端到端数据完整性。

- **事务类型**：

  |       类型        |          用途          |
  | :---------------: | :--------------------: |
  | Memory Read/Write |    访问设备内存空间    |
  |   Configuration   |    读写设备配置空间    |
  |      Message      | 传递中断、电源管理信号 |

##### 2. **数据链路层（Data Link Layer）**

- DLLP（Data Link Layer Packet）：
  - **流量控制**：发送ACK/NAK管理缓冲区状态。
  - **链路维护**：心跳包（Keepalive）检测链路存活。
- 序列号与重传：
  - 每个TLP分配序列号，接收端通过ACK确认，超时或错误触发重传。
  - **LCRC（Link CRC）**：校验TLP在链路上的传输完整性。



## 3. RTOS

### OSInit

- **初始化 μC/OS-II 内核的所有数据结构**（初始化**内核变量** `OSRunning`/`OSIntNesting`，空闲任务`Idle Task`，任务控制块`TCB`，就绪列表，内存管理，定时器等），为多任务环境搭建基础框架。

- 必须在创建任务（`OSTaskCreate()`）和启动调度器（`OSStart()`）前调用。

> Q1：`OSInit()` 是否会初始化用户任务的堆栈？
>
> A1：不会。`OSInit()` 仅初始化内核数据结构和系统任务（如空闲任务），用户任务的堆栈需在 `OSTaskCreate()` 中自行分配。

### OSIntEnter/OSIntExit

- **`OSIntEnter()`**：

  - 将全局变量 `OSIntNesting` 加 1，记录嵌套层数。

  - **不关闭中断**，允许更高优先级中断抢占。

```c
void OSIntEnter(void) {
    if (OSRunning == OS_TRUE) {
        OS_CPU_CRITICAL_ENTER();
        OSIntNesting++;  // 嵌套计数器递增
        OS_CPU_CRITICAL_EXIT();
    }
}
```

- **`OSIntExit()`**：
  - 递减 `OSIntNesting`，当嵌套层数为 0 时触发任务调度。
  - 调用 `OS_SchedNew()` 查找最高优先级任务，若需要切换则执行上下文切换。
  - 必须 **在 ISR 末尾调用**，否则可能导致任务调度延迟。

> Q1：若忘记调用 `OSIntExit()` 会导致什么问题？
>
> A1：`OSIntNesting` 无法递减，任务调度被阻塞，系统可能卡在中断上下文无法返回任务模式。



## 4. Linux

#### net_device

描述网络设备的**核心数据结构**，每个网络接口（如以太网卡、虚拟网卡）在内核中均对应一个 `net_device` 实例。

1. **基础信息与配置**

- `mtu`：最大传输单元（Maximum Transmission Unit），默认 1500 字节。
- `flags`：设备状态标志，如 `IFF_UP`（设备已启动）、`IFF_PROMISC`（混杂模式）。
- `features`：硬件特性支持，如校验和卸载（`NETIF_F_HW_CSUM`）、TSO。

2. **操作函数集**

- `ndo_open`：打开设备（如申请资源、启用中断）。

- `ndo_stop`：关闭设备（如释放资源、禁用中断）。

- `ndo_start_xmit`：发送数据包（将 `sk_buff` 提交到硬件队列）。

- `ndo_get_stats`：获取设备统计信息（发送/接收字节数、错误计数等）。

- `ndo_do_ioctl`：处理用户空间 `ioctl` 命令（如设置混杂模式）。

- `ndo_set_rx_mode`：设置接收模式（如更新 MAC 过滤器）。

3. **队列与中断管理**

- `napi_struct`：NAPI（New API）结构体，用于在高负载时轮询接收数据包，减少中断开销。
- `tx_queue_len`：发送队列最大长度（若设备支持队列管理）。
