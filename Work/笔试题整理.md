# 笔试题整理

### 大疆2025：:star::star::star:最短冷却时间序列

给定一个仅包含大写字母A-Z的字符串str和一个冷却时间cold，构造一个由str中所有字符组成的序列，要求：

1. 每个字符的出现次数与str中相同
2. 相同字符之间的间隔必须至少为cold次（用COLD占位）
3. 返回满足条件的最短序列长度

### 示例

输入：str = "AAABBB"，cold = 2

输出：8

解释：构造序列：A->B->COLD->A->B->COLD->A->B，总长度为8

### 思路

1. 统计频率：使用哈希表统计每个字符的出现次数
2. 贪心策略：使用最大堆优先处理剩余次数最多的字符
3. 冷却管理：用队列维护正在冷却的字符及其解冻时间
4. 模拟过程：
   - 每次从堆顶取出字符处理
   - 处理后将字符放入冷却队列
   - 若堆为空则插入COLD
   - 检查冷却队列中已解冻的字符重新加入堆

### 代码

```c
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

int shortestSequenceLength(string str, int cold) {
    // 统计字符频率
    unordered_map<char, int> freq;
    for(char c : str) freq[c]++;
    
    // 最大堆存储字符及其剩余次数
    priority_queue<pair<int, char>> maxHeap;
    for(auto& [c, cnt] : freq) 
        maxHeap.push({cnt, c});
    
    // 冷却队列存储解冻时间和字符
    queue<pair<int, char>> cooling;
    int time = 0;
    
    while(!maxHeap.empty() || !cooling.empty()) {
        time++;
        
        // 检查是否有字符解冻
        if(!cooling.empty() && cooling.front().first <= time) {
            auto [_, c] = cooling.front();
            cooling.pop();
            maxHeap.push({freq[c], c});
        }
        
        if(!maxHeap.empty()) {
            auto [cnt, c] = maxHeap.top();
            maxHeap.pop();
            freq[c]--;
            
            // 如果还有剩余次数，加入冷却队列
            if(freq[c] > 0) 
                cooling.push({time + cold + 1, c});
        }
    }
    return time;
}
```